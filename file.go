package enki

import (
	"bytes"
	"go/format"
	"io"
	"os"
	"strings"

	"github.com/pkg/errors"
)

// Block builder that can be materialized
type Block interface {
	materialize() string
}

// File builder for files
type File interface {
	Statement
	GeneratedBy(tool string)
	Package(pkg string)
	Import(alias, path string)
	Add(b Block)
	Write(dest io.Writer) error
	Create(fileName string) error
}

type file struct {
	*statement
	generatedComment string
	pkg              string
	imports          []string
	blocks           []Block
}

// NewFile creates new file.
func NewFile() *file {
	return &file{
		statement: Stmt(),
	}
}

func (f *file) GeneratedBy(tool string) {
	f.generatedComment = "// Code generated by " + tool + ". DO NOT EDIT."
}

func (f *file) Package(pkg string) {
	f.pkg = pkg
}

func (f *file) Import(alias, path string) {
	def := alias + " " + path
	f.imports = append(f.imports, def)
}

func (f *file) Add(b Block) {
	f.blocks = append(f.blocks, b)
}

func (f *file) NewLine() {
	stmt := Stmt()
	stmt.NewLine()
	f.blocks = append(f.blocks, stmt)
}

func (f *file) Line(s string, args ...interface{}) Statement {
	f.blocks = append(f.blocks, Stmt().Line(s, args...))
	return f
}

func (f *file) Write(dest io.Writer) error {
	if f.err != nil {
		return f.err
	}

	if f.generatedComment != "" {
		f.statement.Line(f.generatedComment)
	}

	f.statement.Line("package @1", f.pkg)

	if len(f.imports) > 0 {
		f.statement.Line("import (")
		for _, s := range f.imports {
			f.statement.Line(`"@1"`, strings.Trim(s, " "))
		}
		f.statement.Line(")")
	}

	buf := bytes.NewBufferString(f.String())

	for _, block := range f.blocks {
		buf.WriteString(block.materialize())
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return errors.Wrap(err, "go fmt file")
	}

	_, err = dest.Write(formatted)
	if err != nil {
		return errors.Wrap(err, "write to dest")
	}

	return nil
}

func (f *file) Create(fileName string) error {
	file, err := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return errors.Wrap(err, "create file")
	}
	defer file.Close()
	if err = f.Write(file); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil
}
